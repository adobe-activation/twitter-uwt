'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _layoutObserver = require('layout-observer');

var _layoutObserver2 = _interopRequireDefault(_layoutObserver);

var _addStylesToPage = require('../utils/addStylesToPage');

var _addStylesToPage2 = _interopRequireDefault(_addStylesToPage);

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = new _logger2.default('Frameboyant:Parent'); /*************************************************************************
                                                         * ADOBE CONFIDENTIAL
                                                         * ___________________
                                                         *
                                                         *  Copyright 2016 Adobe Systems Incorporated
                                                         *  All Rights Reserved.
                                                         *
                                                         * NOTICE:  All information contained herein is, and remains
                                                         * the property of Adobe Systems Incorporated and its suppliers,
                                                         * if any.  The intellectual and technical concepts contained
                                                         * herein are proprietary to Adobe Systems Incorporated and its
                                                         * suppliers and are protected by all applicable intellectual property
                                                         * laws, including trade secret and copyright laws.
                                                         * Dissemination of this information or reproduction of this material
                                                         * is strictly forbidden unless prior written permission is obtained
                                                         * from Adobe Systems Incorporated.
                                                         **************************************************************************/

var STYLES = '\n  .frameboyantIframe {\n    box-sizing: border-box;\n    width: 100%;\n  }\n  \n  .frameboyantIframeContainer {\n    width: 100%;\n    height: 100%;\n  }\n    \n  .frameboyantRoot.editMode .frameboyantIframeContainer {\n    position: absolute;\n    /* Width and height will be inlined as necessary */\n    width: auto;\n    height: auto;\n  }\n  \n  .frameboyantIframe {\n    width: 100%;\n    height: 100%;\n    border: 0;\n  }\n';

(0, _addStylesToPage2.default)(STYLES);

var getEditModeMeasurements = function getEditModeMeasurements(iframeContainer, boundsContainer, root) {
  // Typically, boundsContainer contains offsetParent which contains root which contains
  // iframeContainer which contains iframe.

  // boundsContainer is the container that should be filled by the iframe while in edit mode.

  // offsetParent is the first ancestor of iframeContainer that has non-static positioning. When
  // iframeContainer is set to position:absolute, its top, right, bottom, and left positions will
  // be based on that. In other words, if iframeContainer has top: 0, right: 0, bottom: 0, left: 0,
  // it would be the same size as the offsetParent.

  // root is the parent-most container that frameboyant creates and controls. Its positioning will
  // always be static and its height will match the height of the iframe's content. In other words,
  // its height will not change when toggling edit mode.

  // iframeContainer contains the iframe and is toggled between absolute and static positioning
  // when going in and out of edit mode. When in edit mode, it will fill up the bounds container
  // and when not in edit mode it will fill up the root container. This container is only necessary
  // because browsers don't allow sizing an iframe using top, right, bottom, and left measurements.
  // Instead, we size the iframeContainer and set the iframe to 100% width and 100% height.

  // iframe The iframe. Since the iframe is 100% width and 100% height of iframeContainer, we
  // don't directly manipulate its positioning/sizing.
  var boundsContainerStyle = getComputedStyle(boundsContainer);
  var boundsContainerRect = boundsContainer.getBoundingClientRect();
  var offsetParent = iframeContainer.offsetParent;
  var offsetParentStyle = getComputedStyle(offsetParent);
  var offsetParentRect = offsetParent.getBoundingClientRect();
  var rootRect = root.getBoundingClientRect();

  // Find the top, left, right, and bottom styles that would need to be applied to the iframe
  // container in order to make the iframe cover the bounds container. The iframe should cover
  // everything in the bounds container except for the border.
  var iframeContainerMeasurements = {
    top: parseFloat(offsetParentStyle.borderTopWidth) + (offsetParentRect.top - boundsContainerRect.top) - parseFloat(boundsContainerStyle.borderTopWidth),
    left: parseFloat(offsetParentStyle.borderLeftWidth) + (offsetParentRect.left - boundsContainerRect.left) - parseFloat(boundsContainerStyle.borderLeftWidth),
    right: parseFloat(offsetParentStyle.borderRightWidth) + (boundsContainerRect.right - offsetParentRect.right) - parseFloat(boundsContainerStyle.borderRightWidth),
    bottom: parseFloat(offsetParentStyle.borderBottomWidth) + (boundsContainerRect.bottom - offsetParentRect.bottom) - parseFloat(boundsContainerStyle.borderBottomWidth)
  };

  // Find the dimensions where the iframe's content should be. This will be sent into the iframe
  // and applied to the iframe's body.
  var iframeContentMeasurements = {
    top: rootRect.top - boundsContainerRect.top - parseFloat(boundsContainerStyle.borderTopWidth),
    left: rootRect.left - boundsContainerRect.left - parseFloat(boundsContainerStyle.borderLeftWidth),
    width: root.clientWidth
  };

  return {
    iframeContainerMeasurements: iframeContainerMeasurements,
    iframeContentMeasurements: iframeContentMeasurements
  };
};

exports.default = function (_ref) {
  var editModeBoundsContainer = _ref.editModeBoundsContainer,
      editModeZIndex = _ref.editModeZIndex;

  logger.log('Initializing an iframe');

  var child = void 0;
  var iframe = void 0;
  var exitEditModeOnFocus = true;

  var root = document.createElement('div');
  root.classList.add('frameboyantRoot');

  var iframeContainer = document.createElement('div');
  iframeContainer.classList.add('frameboyantIframeContainer');
  root.appendChild(iframeContainer);

  var updateDomForEditMode = function updateDomForEditMode() {
    var iframeContainerStyle = iframeContainer.style;

    var _getEditModeMeasureme = getEditModeMeasurements(iframeContainer, editModeBoundsContainer, root),
        iframeContainerMeasurements = _getEditModeMeasureme.iframeContainerMeasurements,
        iframeContentMeasurements = _getEditModeMeasureme.iframeContentMeasurements;

    // We have to be careful not to perform any of the operations below unless the values are
    // actually changing, otherwise they will trigger our mutation observer in at least Firefox
    // which causes an infinite loop.

    if (!root.classList.contains('editMode')) {
      root.classList.add('editMode');
    }

    var newZIndex = String(editModeZIndex);
    if (iframeContainerStyle.zIndex !== newZIndex) {
      iframeContainerStyle.zIndex = newZIndex;
    }

    Object.keys(iframeContainerMeasurements).forEach(function (side) {
      // Some browsers, like Firefox, do some rounding internally (to the tenth of a pixel) so
      // when we set a value of, say, "1.74939939057px", it's rounded internally to "1.7px".
      // Our mutation observer is triggered which brings us back into this function and because
      // "1.74939939057px" does not match "1.7px", we attempt to set the style again, which
      // continues the cycle, causing an infinite loop.
      var newMeasurement = Math.round(-iframeContainerMeasurements[side]) + 'px';
      if (iframeContainerStyle[side] !== newMeasurement) {
        iframeContainerStyle[side] = newMeasurement;
      }
    });

    return iframeContentMeasurements;
  };

  var updateDomForNormalMode = function updateDomForNormalMode() {
    var iframeContainerStyle = iframeContainer.style;

    root.classList.remove('editMode');
    iframeContainerStyle.removeProperty('z-index');
    iframeContainerStyle.removeProperty('top');
    iframeContainerStyle.removeProperty('left');
    iframeContainerStyle.removeProperty('right');
    iframeContainerStyle.removeProperty('bottom');
  };

  var handleLayoutChange = function handleLayoutChange() {
    logger.log('Layout mutation observed');
    if (child) {
      child.setContentRect(updateDomForEditMode());
    }
  };

  // Watch for any UI mutations in the parent window. If any are seen, we need to update the
  // content position inside the iframe. This is only necessary when we're in edit mode.
  var layoutObserver = new _layoutObserver2.default(handleLayoutChange, {
    throttle: 10
  });

  var handleFocus = function handleFocus(event) {
    // In at least IE 11, if something in the iframe gains focus, we'll get an event with iframe
    // as the target.
    if (exitEditModeOnFocus && child && event.target !== iframe) {
      child.exitEditMode();
    }
  };

  return {
    root: root,
    iframeContainer: iframeContainer,
    /**
     * Provides frameboyant with an API object for managing the child iframe.
     * @param value
     */
    setChild: function setChild(value) {
      child = value;
    },


    /**
     * Provides frameboyant with the child iframe.
     * @param value
     */
    setIframe: function setIframe(value) {
      iframe = value;
      iframe.classList.add('frameboyantIframe');
    },


    /**
     * This should be called when the iframe has entered edit mode. The parent window will also
     * enter edit mode.
     */
    editModeEntered: function editModeEntered() {
      logger.log('Entering edit mode');
      var iframeContentRect = updateDomForEditMode();
      layoutObserver.observe();
      document.addEventListener('focus', handleFocus, true);
      return iframeContentRect;
    },


    /**
     * This should be called when the iframe has exited edit mode. The parent window will also exit
     * edit mode
     */
    editModeExited: function editModeExited() {
      logger.log('Exiting edit mode');
      layoutObserver.disconnect();
      document.removeEventListener('focus', handleFocus, true);
      updateDomForNormalMode();
    },


    /**
     * Sets the iframe's height.
     * @param height
     */
    setIframeHeight: function setIframeHeight(height) {
      logger.log('Setting iframe height', height);
      root.style.height = height + 'px';
    },


    /**
     * When exitEditModeOnFocus is set to true, edit mode will be exited when an element outside
     * the iframe gains focus.
     * @param value
     */
    setExitEditModeOnFocus: function setExitEditModeOnFocus(value) {
      exitEditModeOnFocus = value;
    },


    /**
     * Removes event listeners and removes associated elements from the DOM.
     */
    destroy: function destroy() {
      layoutObserver.disconnect();
      document.removeEventListener('focus', handleFocus, true);

      if (root.parentNode) {
        root.parentNode.removeChild(root);
      }
    }
  };
};