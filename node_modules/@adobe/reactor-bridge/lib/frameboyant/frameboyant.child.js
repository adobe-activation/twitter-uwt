'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _layoutObserver = require('layout-observer');

var _layoutObserver2 = _interopRequireDefault(_layoutObserver);

var _addStylesToPage = require('../utils/addStylesToPage');

var _addStylesToPage2 = _interopRequireDefault(_addStylesToPage);

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _once = require('once');

var _once2 = _interopRequireDefault(_once);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***************************************************************************************
 * (c) 2017 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

var logger = new _logger2.default('Frameboyant:Child');

var STYLES = '\n  html {\n    margin: 0 !important;\n    \n    /*\n      When something in the iframe changes the document height, we send a message to the parent\n      window and the window resizes the iframe accordingly. This process is asynchronous,\n      however, and while the message is being communicated to the parent window, a vertical\n      scrollbar appears. This prevents the scrollbar from showing up.\n    */\n    overflow: hidden !important;\n  }\n  \n  html, body {\n    /*\n      Prevent infinite resizing\n    */\n    height: auto !important;\n    background-color: transparent !important;\n  }\n  \n  body {\n    /*\n      border-box sizing is important to get body sizing right when the extension has applied\n      padding to the body element.\n    */\n    box-sizing: border-box !important;\n    margin: 0 !important;\n    display: block !important;\n    position: relative !important;\n    height: 100% !important;\n  }\n  \n  /* \n    When in edit mode, we\'ll be giving body some margin. If the children of body also have \n    margin, this can cause their margins to "collapse" into the body\'s margin. \n    https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing.\n    This hack prevents margins from collapsing while (hopefully) not causing any\n    problematic side-effects.\n  */\n  body:before,\n  body:after {\n    content: \' \';\n    display: table;\n  }\n\n  /*\n    Toggling edit mode is an asynchronous operation due to postMessage being asynchronous. While\n    toggling, the iframe gets shifted around the parent document at times causing the user to\n    see the iframe\'s content moving around the page. To prevent this from happening, we\'ll hide\n    the body which hopefully will be a better form of flicker. We tried setting visibility to \n    hidden, but it appeared to cause issues with React synthetic events (mousedown, blur, etc)\n    after it was unhidden. Tweaking opacity is our best attempt at hiding the content \n    without causing problems.\n  */\n  .frameboyantTogglingEditMode {\n    opacity: 0 !important;\n  }\n';

var parent = void 0;
var editMode = false;

var handleMouseDown = function handleMouseDown(event) {
  if (event.button === 0) {
    // main mouse button
    if (editMode) {
      if (event.target === document.documentElement) {
        exitEditMode();
      }
    } else {
      enterEditMode();
    }
  }
};

var setContentRect = function setContentRect(rect) {
  var bodyStyle = document.body.style;
  bodyStyle.setProperty('margin-top', rect.top + 'px', 'important');
  bodyStyle.setProperty('margin-left', rect.left + 'px', 'important');
  bodyStyle.setProperty('width', rect.width + 'px', 'important');
  logger.log('content rect set', rect);
};

var clearContentRect = function clearContentRect() {
  var bodyStyle = document.body.style;
  bodyStyle.removeProperty('margin-top');
  bodyStyle.removeProperty('margin-left');
  bodyStyle.removeProperty('width');
  logger.log('content rect cleared');
};

var enterEditMode = function enterEditMode() {
  if (parent && !editMode) {
    logger.log('entering edit mode');
    editMode = true;
    document.body.classList.add('frameboyantTogglingEditMode');

    return parent.editModeEntered().then(function (contentRect) {
      setContentRect(contentRect);
      document.body.classList.remove('frameboyantTogglingEditMode');
    });
  }
};

var exitEditMode = function exitEditMode() {
  if (parent && editMode) {
    logger.log('exiting edit mode');
    editMode = false;
    document.body.classList.add('frameboyantTogglingEditMode');

    parent.editModeExited().then(function () {
      clearContentRect();
      document.body.classList.remove('frameboyantTogglingEditMode');
    });
  }
};

var handleLayoutChange = function () {
  var previousObservedHeight = -1;

  return function () {
    var bodyHeight = document.body.offsetHeight;
    if (previousObservedHeight !== bodyHeight) {
      if (parent) {
        parent.setIframeHeight(bodyHeight);
      }

      previousObservedHeight = bodyHeight;
    }
  };
}();

var layoutObserver = new _layoutObserver2.default(handleLayoutChange, {
  throttle: 10
});

var setParent = (0, _once2.default)(function (value) {
  parent = value;
  layoutObserver.observe();
  handleLayoutChange(); // Let the parent know about our initial height.
});

document.addEventListener('mousedown', handleMouseDown, true);
document.addEventListener('focus', enterEditMode, true);
(0, _addStylesToPage2.default)(STYLES);

exports.default = {
  /**
   * Provides frameboyant with an API object for managing the parent window.
   * @param value
   */
  setParent: setParent,
  /**
   * Provides top, left, and width for where the content should be oriented inside the iframe.
   */
  setContentRect: setContentRect,
  /**
   * Called when the parent window wishes to enter edit mode.
   */
  enterEditMode: enterEditMode,
  /**
   * Called when the parent window wishes to exit edit mode.
   */
  exitEditMode: exitEditMode
};