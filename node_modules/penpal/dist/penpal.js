// Derived from https://github.com/umdjs/umd/blob/master/templates/amdWebGlobal.js
(function (root, factory) {
  var exports = {};
  factory(exports);

  if (typeof define === 'function' && define.amd) {
    // AMD
    define('Penpal', exports.default);
  } else {
    // Browser global
    root.Penpal = exports.default;
  }
}(this, function (exports) {

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var PARENT = 'parent';
var CHILD = 'child';
var HANDSHAKE = 'handshake';
var HANDSHAKE_REPLY = 'handshake-reply';
var CALL = 'call';
var REPLY = 'reply';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var MESSAGE = 'message';
var LOAD = 'load';

var DEFAULT_PORTS = {
  'http:': '80',
  'https:': '443'
};

var Penpal = {
  /**
   * Promise implementation.
   * @type {Constructor}
   */
  Promise: function () {
    try {
      return window ? window.Promise : null;
    } catch (e) {
      return null;
    }
  }(),
  /**
   * Whether debug messages should be logged.
   * @type {boolean}
   */
  debug: false
};

/**
 * @return {number} A unique ID (not universally unique)
 */
var generateId = function () {
  var id = 0;
  return function () {
    return ++id;
  };
}();

/**
 * Logs a message.
 * @param {...*} args One or more items to log
 */
var log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (Penpal.debug) {
    var _console;

    (_console = console).log.apply(_console, ['[Penpal]'].concat(args)); // eslint-disable-line no-console
  }
};

/**
 * Converts a URL into an origin.
 * @param {string} url
 * @return {string} The URL's origin
 */
var getOriginFromUrl = function getOriginFromUrl(url) {
  var location = document.location;
  var a = document.createElement('a');
  a.href = url;

  var origin = void 0;

  if (a.origin) {
    origin = a.origin;
  } else {
    var protocol = a.protocol || location.protocol;
    var hostname = a.hostname || location.hostname;
    var port = a.port || location.port;
    // If the port is the default for the protocol, we don't want to add it to the origin string
    // or it won't match the message's event.origin.
    origin = protocol + '//' + hostname + (port && port !== DEFAULT_PORTS[protocol] ? ':' + port : '');
  }

  return origin;
};

/**
 * A simplified promise class only used internally for when destroy() is called. This is
 * used to destroy connections synchronously while promises typically resolve asynchronously.
 *
 * @param {Function} executor
 * @returns {Object}
 * @constructor
 */
var DestructionPromise = function DestructionPromise(executor) {
  var handlers = [];

  executor(function () {
    handlers.forEach(function (handler) {
      handler();
    });
  });

  return {
    then: function then(handler) {
      handlers.push(handler);
    }
  };
};

/**
 * Creates an object with methods that match those defined by the remote. When these methods are
 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
 * executed, and the method's return value will be returned via a message.
 * @param {Object} info Information about the local and remote windows.
 * @param {Array} methodNames Names of methods available to be called on the remote.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Object} An object with methods that may be called.
 */
var createCallSender = function createCallSender(info, methodNames, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;

  var destroyed = false;

  log(localName + ': Creating call sender');

  var createMethodProxy = function createMethodProxy(methodName) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log(localName + ': Sending ' + methodName + '() call');
      return new Penpal.Promise(function (resolve, reject) {
        if (destroyed) {
          reject('Unable to send ' + methodName + '() call due to destroyed connection');
          return;
        }

        var id = generateId();
        var handleMessageEvent = function handleMessageEvent(event) {
          if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id) {
            log(localName + ': Received ' + methodName + '() reply');
            local.removeEventListener(MESSAGE, handleMessageEvent);
            (event.data.resolution === FULFILLED ? resolve : reject)(event.data.returnValue);
          }
        };

        local.addEventListener(MESSAGE, handleMessageEvent);
        remote.postMessage({
          penpal: CALL,
          id: id,
          methodName: methodName,
          args: args
        }, remoteOrigin);
      });
    };
  };

  destructionPromise.then(function () {
    destroyed = true;
  });

  return methodNames.reduce(function (api, methodName) {
    api[methodName] = createMethodProxy(methodName);
    return api;
  }, {});
};

/**
 * Listens for "call" messages coming from the remote, executes the corresponding method, and
 * responds with the return value.
 * @param {Object} info Information about the local and remote windows.
 * @param {Object} methods The keys are the names of the methods that can be called by the remote
 * while the values are the method functions.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Function} A function that may be called to disconnect the receiver.
 */
var connectCallReceiver = function connectCallReceiver(info, methods, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;

  var destroyed = false;

  log(localName + ': Connecting call receiver');

  var handleMessageEvent = function handleMessageEvent(event) {
    if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
      (function () {
        var _event$data = event.data,
            methodName = _event$data.methodName,
            args = _event$data.args,
            id = _event$data.id;


        log(localName + ': Received ' + methodName + '() call');

        if (methodName in methods) {
          var createPromiseHandler = function createPromiseHandler(resolution) {
            return function (returnValue) {
              if (destroyed) {
                // We have to throw the error after a timeout otherwise we're just continuing
                // the promise chain with a failed promise.
                setTimeout(function () {
                  throw new Error('Unable to send ' + methodName + '() reply due to destroyed connection');
                });
                return;
              }

              log(localName + ': Sending ' + methodName + '() reply');

              remote.postMessage({
                penpal: REPLY,
                id: id,
                resolution: resolution,
                returnValue: returnValue
              }, remoteOrigin);
            };
          };

          new Penpal.Promise(function (resolve, reject) {
            try {
              // The consumer's function may throw an error, return a raw return value, return
              // a promise that resolves, or return a promise that gets rejected.
              // In the case that it throws an error, we'll send the error stack as a reply
              resolve(methods[methodName].apply(methods, _toConsumableArray(args)));
            } catch (err) {
              reject(err.toString());
              setTimeout(function () {
                throw err;
              });
            }
          }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
        }
      })();
    }
  };

  local.addEventListener(MESSAGE, handleMessageEvent);

  destructionPromise.then(function () {
    destroyed = true;
    local.removeEventListener(MESSAGE, handleMessageEvent);
  });
};

/**
 * @typedef {Object} Child
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 * @property {HTMLIframeElement} iframe The created iframe element.
 * @property {Function} destroy A method that, when called, will remove the iframe element from
 * the DOM and clean up event listeners.
 */

/**
 * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with
 * the iframe.
 * @param {Object} options
 * @param {string} options.url The URL of the webpage that should be loaded into the created iframe.
 * @param {HTMLElement} [options.appendTo] The container to which the iframe should be appended.
 * @param {Object} [options.methods] Methods that may be called by the iframe.
 * @return {Child}
 */
Penpal.connectToChild = function (_ref) {
  var url = _ref.url,
      appendTo = _ref.appendTo,
      _ref$methods = _ref.methods,
      methods = _ref$methods === undefined ? {} : _ref$methods;

  var destroy = void 0;
  var destructionPromise = new DestructionPromise(function (resolve) {
    return destroy = resolve;
  });

  var parent = window;
  var iframe = document.createElement('iframe');

  (appendTo || document.body).appendChild(iframe);

  destructionPromise.then(function () {
    if (iframe.parentNode) {
      iframe.parentNode.removeChild(iframe);
    }
  });

  var child = iframe.contentWindow || iframe.contentDocument.parentWindow;
  var childOrigin = getOriginFromUrl(url);

  var promise = new Penpal.Promise(function (resolve, reject) {
    var handleMessage = function handleMessage(event) {
      if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE_REPLY) {
        log('Parent: Received handshake reply from Child');

        parent.removeEventListener(MESSAGE, handleMessage);

        var info = {
          localName: PARENT,
          local: parent,
          remote: child,
          remoteOrigin: event.origin
        };

        connectCallReceiver(info, methods, destructionPromise);
        resolve(createCallSender(info, event.data.methodNames, destructionPromise));
      }
    };

    var handleIframeLoaded = function handleIframeLoaded() {
      log('Parent: Sending handshake');

      parent.addEventListener(MESSAGE, handleMessage);

      destructionPromise.then(function () {
        parent.removeEventListener(MESSAGE, handleMessage);
      });

      child.postMessage({
        penpal: HANDSHAKE,
        methodNames: Object.keys(methods)
      }, childOrigin);
    };

    iframe.addEventListener(LOAD, handleIframeLoaded);

    destructionPromise.then(function () {
      iframe.removeEventListener(LOAD, handleIframeLoaded);
      reject('Parent: Connection destroyed');
    });

    log('Parent: Loading iframe');

    iframe.src = url;
  });

  return {
    promise: promise,
    iframe: iframe,
    destroy: destroy
  };
};

/**
 * @typedef {Object} Parent
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 */

/**
 * Attempts to establish communication with the parent window.
 * @param {Object} options
 * @param {string|Array} [options.parentOrigin] A parent origin used to restrict communication.
 * An array of parent origin strings is also supported.
 * @param {Object} [options.methods] Methods that may be called by the parent window.
 * @return {Parent}
 */
Penpal.connectToParent = function (_ref2) {
  var parentOrigin = _ref2.parentOrigin,
      _ref2$methods = _ref2.methods,
      methods = _ref2$methods === undefined ? {} : _ref2$methods;

  var destroy = void 0;
  var destructionPromise = new DestructionPromise(function (resolve) {
    return destroy = resolve;
  });

  var child = window;
  var parent = child.parent;

  if (parentOrigin !== undefined && !Array.isArray(parentOrigin)) {
    parentOrigin = [parentOrigin];
  }

  var promise = new Penpal.Promise(function (resolve, reject) {
    var handleMessageEvent = function handleMessageEvent(event) {
      if ((parentOrigin === undefined || parentOrigin.indexOf(event.origin) !== -1) && event.data.penpal === HANDSHAKE) {
        log('Child: Received handshake from Parent');

        child.removeEventListener(MESSAGE, handleMessageEvent);

        log('Child: Sending handshake reply to Parent');

        event.source.postMessage({
          penpal: HANDSHAKE_REPLY,
          methodNames: Object.keys(methods)
        }, event.origin);

        var info = {
          localName: CHILD,
          local: child,
          remote: parent,
          remoteOrigin: event.origin
        };

        connectCallReceiver(info, methods, destructionPromise);
        resolve(createCallSender(info, event.data.methodNames, destructionPromise));
      }
    };

    child.addEventListener(MESSAGE, handleMessageEvent);

    destructionPromise.then(function () {
      child.removeEventListener(MESSAGE, handleMessageEvent);
      reject('Child: Connection destroyed');
    });
  });

  return {
    promise: promise,
    destroy: destroy
  };
};

exports.default = Penpal;

}));
